import hashlib
import binascii
from os import urandom
from enum import Enum
import bitstring

#main types of WOTS defined fromt he ain paper
class WinternizAlgorithm(Enum):
    LMOTS_SHA256_N32_W1 = object()
    LMOTS_SHA256_N32_W2 = object()
    LMOTS_SHA256_N32_W4 = object()
    LMOTS_SHA256_N32_W8 = object()

    def __repr__(self):
        return '<%s.%s>' % (self.__class__.__name__, self.name)


class Winterniz:

    BITS_PER_BYTE = 256

    def __init__(self, alg_type=WinternizAlgorithm.LMOTS_SHA256_N32_W4):

        #Section 4.1 states the following for the paramapters
        #N: the number of bytes per functiion
        #W: the width of the bits in a member set {1.2.4.8}
        #P: Number of the n-byte string elements that make up the signatue

        if alg_type is WinternizAlgorithm.LMOTS_SHA256_N32_W1:
            self._hash_alg = 'sha256'
            self._wtos_n = 32
            self._wtos_w = 1
            self._wtos_p = 256
        elif alg_type is WinternizAlgorithm.LMOTS_SHA256_N32_W2:
            self._hash_alg = 'sha256'
            self._wtos_n = 32
            self._wtos_w = 2
            self._wtos_p = 128
        elif alg_type is WinternizAlgorithm.LMOTS_SHA256_N32_W4:
            self._hash_alg = 'sha256'
            self._wtos_n = 32
            self._wtos_w = 4
            self._wtos_p = 64
        elif alg_type is WinternizAlgorithm.LMOTS_SHA256_N32_W8:
            self._hash_alg = 'sha256'
            self._wtos_n = 32
            self._wtos_w = 8
            self._wtos_p = 32
        else:
            raise ValueError("unknown Winternitz alg_type")

    def hash(self, data):
        h = hashlib.new(self._hash_alg)
        h.update(data)
        hash_value = h.digest()
        return hash_value

    def generate_key_pair(self):

    #LM-OTS private key is an array size of P containing N byte strings.
    # Private Key must be used to sign one message. it must be unique
    #section 4.4 Algorithm 0 Generating private key
        private_Key = []
        for _ in range(self._wtos_p):
            private_Key.append(urandom(self._wtos_n)) # fill array with random N byte size values

#section 4.5
#LM-OTS pibic key is a pair with assosiatted values. The string must be 32 bytes long.
#the Puvlic kez is generated by applging hash function H(x) for each 2^w -1 itterations hashing all the values

        Public_Key = []
        for i in range(self._wtos_p): #loops P string values
            temp = self.hash(private_Key[i])
            for _ in range(2**self._wtos_w -1): # H to each individual element of x, for 2^w - 1
                temp = self.hash(temp)
            Public_Key.append(temp)
#return
        return Public_Key, private_Key


#4.7 signatue generation

    def sign(self, private_Key, data):

        data_hash = self.hash(data)
        D_MESG = bitstring.ConstBitStream( data_hash)
        data_unit = "uint:{}".format(self._wtos_w)
        u32str = []
        for i in range(self._wtos_p): # for ( i = 0; i < p; i = i + 1 ) {
            temp = private_Key[i] #tmp X[i]
            uint_val = D_MESG.read(data_unit)
            hash_iters = 2**self._wtos_w - uint_val
            for _ in range(hash_iters): # for ( j = 0; j < a; j = j + 1 ) {
                sig_item = self.hash(sig_item)
            u32str.append(sig_item)
        return u32str

    def verify(self, signature, data, Public_Key):
#Algorithm 4: Verifying a Signature and Message Using a Public Key

        data_hash = self.hash(data)
        # break the hash value into a bit stream so we can read w bits at a time into a uint value
        D_MESG = bitstring.ConstBitStream( data_hash)
        data_unit = "uint:{}".format(self._wtos_w)
        verify = []
        # now we complete the hash operations so that in the end we end up with the same public key expected
        for i in range(self._wtos_p):
            verify_item = signature[i]
            hashItterateVal = D_MESG.read(D_MESG)
            for _ in range(hashItterateVal):
                verify_item = self.hash(verify_item)
            verify.append(verify_item)
        # return the result of the comparison of the verify list with the comparison public key
        return pub_key == verify




def hex_encode(data):
    return binascii.hexlify(data)


if __name__ == "__main__":


    message = b"this is a test message"

    w = Winterniz(alg_type=WinternizAlgorithm.LMOTS_SHA256_N32_W8)

    pub, priv = w.generate_key_pair()

    print("Private key:")
    for j in range(len(priv)):
        print("Priv[{}]: {}".format(j, hex_encode(priv[j])))

    print("\r\n Public key:")
    for j in range(len(pub)):
        print("Pub[{}]: {}".format(j, hex_encode(pub[j])))

    print("\r\nMessage to sign:")
    print("m:\t\t{}".format(message))
    print("Hash(message)=\t{}".format(hex_encode(w.hash(message))))

    print("\r\n Signature:")
    sign = w.sign(priv, message)
    for j in range(len(pub)):
        print("Sig[{}]: {}".format(j, hex_encode(sign[j])))

    print("\r\nSIGNATURE_VALID: ", w.verify(sign, message, pub))
